// DO NOT EDIT : Automatically generated by Slyce v0.1.0 @ 11/29/2020
package slyce.metaSelf

import scala.annotation.tailrec

import scalaz.\/
import scalaz.-\/
import scalaz.\/-
import scalaz.Scalaz.ToBooleanOpsFromBoolean
import scalaz.Scalaz.ToOptionIdOps

import slyce.common.helpers._
import slyce.parse._
import slyce.parse.{architecture => arch}

object Data {

  sealed trait Token extends Dfa.Token
  sealed trait HasSpanToken extends Token with Dfa.Token.HasSpan
  object Token {
    case object EOF extends Token
    object __ {

      def apply(str: String, span: Dfa.Token.Span): Token =
        str match {
          case "\n" =>
            `\n`.apply(span)
          case "|" =>
            `|`.apply(span)
          case "~" =>
            `~`.apply(span)
          case "@start" =>
            `@start`.apply(span)
          case "(" =>
            `(`.apply(span)
          case ")" =>
            `)`.apply(span)
          case "." =>
            `.`.apply(span)
          case "+" =>
            `+`.apply(span)
          case "*" =>
            `*`.apply(span)
          case ":" =>
            `:`.apply(span)
          case "^" =>
            `^`.apply(span)
          case "?" =>
            `?`.apply(span)
          case _ =>
            ???
        }

      final case class `\n`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `|`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `~`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `@start`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `(`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `)`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `.`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `+`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `*`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `:`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `^`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `?`(span: Dfa.Token.Span) extends HasSpanToken
    }
    final case class assocDir(text: String, span: Dfa.Token.Span) extends HasSpanToken
    final case class literal(text: String, span: Dfa.Token.Span) extends HasSpanToken
    final case class nonTerminal(text: String, span: Dfa.Token.Span) extends HasSpanToken
    final case class terminal(text: String, span: Dfa.Token.Span) extends HasSpanToken
  }
  object HasSpanToken {
    def unapply(arg: HasSpanToken): Option[Dfa.Token.Span] = arg.span.some
  }

  sealed trait NonTerminal
  object NonTerminal {

    sealed trait `Optional_?` extends NonTerminal {

      def toOption: Option[Token.__.`?`] =
        this match {
          case `Optional_?`._1(n) =>
            n.some
          case `Optional_?`._2 =>
            None
        }

    }
    object `Optional_?` {

      final case class _1(
        _1: Token.__.`?`,
      ) extends `Optional_?`

      case object _2 extends `Optional_?`

    }

    sealed trait `Optional_^` extends NonTerminal {

      def toOption: Option[Token.__.`^`] =
        this match {
          case `Optional_^`._1(n) =>
            n.some
          case `Optional_^`._2 =>
            None
        }

    }
    object `Optional_^` {

      final case class _1(
        _1: Token.__.`^`,
      ) extends `Optional_^`

      case object _2 extends `Optional_^`

    }

    sealed trait AnonList1 extends NonTerminal {

      def toList: List[Token.__.`\n`] = {
        @tailrec
        def loop(unseen: AnonList1, seen: List[Token.__.`\n`]): List[Token.__.`\n`] =
          unseen match {
            case AnonList1._1(n, tail) =>
              loop(tail, n :: seen)
            case AnonList1._2 =>
              seen.reverse
          }

          loop(this, Nil)
      }

    }
    object AnonList1 {

      final case class _1(
        _1: Token.__.`\n`,
        _2: NonTerminal.AnonList1,
      ) extends AnonList1

      case object _2 extends AnonList1

    }

    sealed trait AnonList2 extends NonTerminal {

      def toList: List[Token.__.`\n`] = {
        @tailrec
        def loop(unseen: AnonList2_2, seen: List[Token.__.`\n`]): List[Token.__.`\n`] =
          unseen match {
            case AnonList2_2._1(n, tail) =>
              loop(tail, n :: seen)
            case AnonList2_2._2 =>
              seen.reverse
        }

        this match {
          case AnonList2._1(n, tail) =>
            loop(tail, n :: Nil)
        }
      }

    }
    object AnonList2 {

      final case class _1(
        _1: Token.__.`\n`,
        _2: NonTerminal.AnonList2_2,
      ) extends AnonList2

    }

    sealed trait AnonList2_2 extends NonTerminal
    object AnonList2_2 {

      final case class _1(
        _1: Token.__.`\n`,
        _2: NonTerminal.AnonList2_2,
      ) extends AnonList2_2

      case object _2 extends AnonList2_2

    }

    sealed trait AnonList3 extends NonTerminal {

      def toList: List[NonTerminal.Nt] = {
        @tailrec
        def loop(unseen: AnonList3_2, seen: List[NonTerminal.Nt]): List[NonTerminal.Nt] =
          unseen match {
            case AnonList3_2._1(_, n, tail) =>
              loop(tail, n :: seen)
            case AnonList3_2._2 =>
              seen.reverse
        }

        this match {
          case AnonList3._1(n, tail) =>
            loop(tail, n :: Nil)
          case AnonList3._2 =>
            Nil
        }
      }

    }
    object AnonList3 {

      final case class _1(
        _1: NonTerminal.Nt,
        _2: NonTerminal.AnonList3_2,
      ) extends AnonList3

      case object _2 extends AnonList3

    }

    sealed trait AnonList3_2 extends NonTerminal
    object AnonList3_2 {

      final case class _1(
        _1: NonTerminal.AnonList2,
        _2: NonTerminal.Nt,
        _3: NonTerminal.AnonList3_2,
      ) extends AnonList3_2

      case object _2 extends AnonList3_2

    }

    sealed trait AnonList4 extends NonTerminal {

      def toList: List[NonTerminal.StdRl] = {
        @tailrec
        def loop(unseen: AnonList4_2, seen: List[NonTerminal.StdRl]): List[NonTerminal.StdRl] =
          unseen match {
            case AnonList4_2._1(_, _, n, tail) =>
              loop(tail, n :: seen)
            case AnonList4_2._2 =>
              seen.reverse
        }

        this match {
          case AnonList4._1(n, tail) =>
            loop(tail, n :: Nil)
        }
      }

    }
    object AnonList4 {

      final case class _1(
        _1: NonTerminal.StdRl,
        _2: NonTerminal.AnonList4_2,
      ) extends AnonList4

    }

    sealed trait AnonList4_2 extends NonTerminal
    object AnonList4_2 {

      final case class _1(
        _1: NonTerminal.AnonList2,
        _2: Token.__.`|`,
        _3: NonTerminal.StdRl,
        _4: NonTerminal.AnonList4_2,
      ) extends AnonList4_2

      case object _2 extends AnonList4_2

    }

    sealed trait AnonList5 extends NonTerminal {

      def toList: List[NonTerminal.ElementWExtras] = {
        @tailrec
        def loop(unseen: AnonList5_2, seen: List[NonTerminal.ElementWExtras]): List[NonTerminal.ElementWExtras] =
          unseen match {
            case AnonList5_2._1(n, tail) =>
              loop(tail, n :: seen)
            case AnonList5_2._2 =>
              seen.reverse
        }

        this match {
          case AnonList5._1(n, tail) =>
            loop(tail, n :: Nil)
        }
      }

    }
    object AnonList5 {

      final case class _1(
        _1: NonTerminal.ElementWExtras,
        _2: NonTerminal.AnonList5_2,
      ) extends AnonList5

    }

    sealed trait AnonList5_2 extends NonTerminal
    object AnonList5_2 {

      final case class _1(
        _1: NonTerminal.ElementWExtras,
        _2: NonTerminal.AnonList5_2,
      ) extends AnonList5_2

      case object _2 extends AnonList5_2

    }

    sealed trait AnonList6 extends NonTerminal {

      def toList: List[NonTerminal.AssocElement] = {
        @tailrec
        def loop(unseen: AnonList6_2, seen: List[NonTerminal.AssocElement]): List[NonTerminal.AssocElement] =
          unseen match {
            case AnonList6_2._1(_, _, n, tail) =>
              loop(tail, n :: seen)
            case AnonList6_2._2 =>
              seen.reverse
        }

        this match {
          case AnonList6._1(n, tail) =>
            loop(tail, n :: Nil)
        }
      }

    }
    object AnonList6 {

      final case class _1(
        _1: NonTerminal.AssocElement,
        _2: NonTerminal.AnonList6_2,
      ) extends AnonList6

    }

    sealed trait AnonList6_2 extends NonTerminal
    object AnonList6_2 {

      final case class _1(
        _1: NonTerminal.AnonList2,
        _2: Token.__.`|`,
        _3: NonTerminal.AssocElement,
        _4: NonTerminal.AnonList6_2,
      ) extends AnonList6_2

      case object _2 extends AnonList6_2

    }

    sealed trait AnonList extends NonTerminal
    object AnonList {

      final case class _1(
        _1: NonTerminal.ListBase,
        _2: NonTerminal.ListOp,
      ) extends AnonList

    }

    sealed trait AssocElement extends NonTerminal
    object AssocElement {

      final case class _1(
        _1: Token.assocDir,
        _2: NonTerminal.Element,
      ) extends AssocElement

    }

    sealed trait AssocNtBase extends NonTerminal
    object AssocNtBase {

      final case class _1(
        _1: Token.__.`~`,
        _2: NonTerminal.AnonList6,
        _3: NonTerminal.StdNtBase,
      ) extends AssocNtBase

    }

    sealed trait Element extends NonTerminal
    object Element {

      final case class _1(
        _1: Token.literal,
      ) extends Element

      final case class _2(
        _1: Token.terminal,
      ) extends Element

      final case class _3(
        _1: Token.nonTerminal,
      ) extends Element

      final case class _4(
        _1: NonTerminal.AnonList,
      ) extends Element

    }

    sealed trait ElementWExtras extends NonTerminal
    object ElementWExtras {

      final case class _1(
        _1: NonTerminal.`Optional_^`,
        _2: NonTerminal.Element,
        _3: NonTerminal.`Optional_?`,
      ) extends ElementWExtras

    }

    sealed trait Grammar extends NonTerminal
    object Grammar {

      final case class _1(
        _1: NonTerminal.AnonList1,
        _2: Token.__.`@start`,
        _3: Token.nonTerminal,
        _4: NonTerminal.AnonList2,
        _5: NonTerminal.AnonList3,
        _6: NonTerminal.AnonList1,
      ) extends Grammar

    }

    sealed trait ListBase extends NonTerminal
    object ListBase {

      final case class _1(
        _1: NonTerminal.Element,
      ) extends ListBase

      final case class _2(
        _1: Token.__.`(`,
        _2: NonTerminal.AnonList5,
        _3: Token.__.`)`,
      ) extends ListBase

      final case class _3(
        _1: Token.__.`(`,
        _2: NonTerminal.AnonList5,
        _3: Token.__.`.`,
        _4: NonTerminal.AnonList5,
        _5: Token.__.`)`,
      ) extends ListBase

    }

    sealed trait ListNtBase extends NonTerminal
    object ListNtBase {

      final case class _1(
        _1: NonTerminal.ListOp,
        _2: NonTerminal.ListBase,
      ) extends ListNtBase

    }

    sealed trait ListOp extends NonTerminal
    object ListOp {

      final case class _1(
        _1: Token.__.`+`,
      ) extends ListOp

      final case class _2(
        _1: Token.__.`*`,
      ) extends ListOp

    }

    sealed trait Nt extends NonTerminal
    object Nt {

      final case class _1(
        _1: Token.nonTerminal,
        _2: NonTerminal.NtBase,
      ) extends Nt

    }

    sealed trait NtBase extends NonTerminal
    object NtBase {

      final case class _1(
        _1: NonTerminal.StdNtBase,
      ) extends NtBase

      final case class _2(
        _1: NonTerminal.ListNtBase,
      ) extends NtBase

      final case class _3(
        _1: NonTerminal.AssocNtBase,
      ) extends NtBase

    }

    sealed trait StdNtBase extends NonTerminal
    object StdNtBase {

      final case class _1(
        _1: NonTerminal.StdOp,
        _2: NonTerminal.AnonList4,
      ) extends StdNtBase

    }

    sealed trait StdOp extends NonTerminal
    object StdOp {

      final case class _1(
        _1: Token.__.`:`,
      ) extends StdOp

      final case class _2(
        _1: Token.__.`^`,
      ) extends StdOp

    }

    sealed trait StdRl extends NonTerminal {

      def toList: List[NonTerminal.ElementWExtras] = {
        @tailrec
        def loop(unseen: StdRl, seen: List[NonTerminal.ElementWExtras]): List[NonTerminal.ElementWExtras] =
          unseen match {
            case StdRl._1(n, tail) =>
              loop(tail, n :: seen)
            case StdRl._2 =>
              seen.reverse
          }

          loop(this, Nil)
      }

    }
    object StdRl {

      final case class _1(
        _1: NonTerminal.ElementWExtras,
        _2: NonTerminal.StdRl,
      ) extends StdRl

      case object _2 extends StdRl

    }

    sealed trait __Start extends NonTerminal
    object __Start {

      final case class _1(
        _1: NonTerminal.Grammar,
        _2: Token.EOF.type,
      ) extends __Start

    }

  }

}

object GrammarParser extends arch.Parser[String, List[String], Data.NonTerminal.Grammar] {
  import Data._

  private val lexer: Dfa[Token] = ???
  private val grammar: Builder[Token, NonTerminal, NonTerminal.Grammar]#StateMachine = ???

  override def apply(input: String): List[String] \/ NonTerminal.Grammar =
    arch.Parser(lexer, grammar)(input)

}
