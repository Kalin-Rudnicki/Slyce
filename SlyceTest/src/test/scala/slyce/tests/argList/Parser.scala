// DO NOT EDIT : Automatically generated by Slyce v0.1.0 @ 11/21/2020
package slyce.tests.argList

import scala.annotation.tailrec

import scalaz.\/
import scalaz.-\/
import scalaz.\/-
import scalaz.Scalaz.ToBooleanOpsFromBoolean
import scalaz.Scalaz.ToOptionIdOps

import slyce.common.helpers._
import slyce.parse._
import slyce.parse.{architecture => arch}

object Data {

  sealed trait Token extends Dfa.Token
  sealed trait HasSpanToken extends Token with Dfa.Token.HasSpan
  object Token {
    case object EOF extends Token
    object __ {

      def apply(str: String, span: Dfa.Token.Span): Token =
        str match {
          case "," =>
            `,`.apply(span)
          case "(" =>
            `(`.apply(span)
          case ")" =>
            `)`.apply(span)
          case "!" =>
            `!`.apply(span)
          case _ =>
            ???
        }

      final case class `,`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `(`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `)`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `!`(span: Dfa.Token.Span) extends HasSpanToken
    }
    final case class _var(text: String, span: Dfa.Token.Span) extends HasSpanToken
  }
  object HasSpanToken {
    def unapply(arg: HasSpanToken): Option[Dfa.Token.Span] = arg.span.some
  }

  sealed trait NonTerminal
  object NonTerminal {

    sealed trait __Start extends NonTerminal
    object __Start {

      final case class _1(
        _1: NonTerminal.ArgList,
        _2: Token.EOF.type,
      ) extends __Start

    }

    sealed trait AnonList1 extends NonTerminal {

      def toList: List[Token._var] = {
        @tailrec
        def loop(unseen: AnonList1_2, seen: List[Token._var]): List[Token._var] =
          unseen match {
            case AnonList1_2._1(_, n, tail) =>
              loop(tail, n :: seen)
            case AnonList1_2._2 =>
              seen.reverse
        }

        this match {
          case AnonList1._1(n, tail) =>
            loop(tail, n :: Nil)
          case AnonList1._2 =>
            Nil
        }
      }

    }
    object AnonList1 {

      final case class _1(
        _1: Token._var,
        _2: NonTerminal.AnonList1_2,
      ) extends AnonList1

      case object _2 extends AnonList1

    }

    sealed trait AnonList1_2 extends NonTerminal
    object AnonList1_2 {

      final case class _1(
        _1: Token.__.`,`,
        _2: Token._var,
        _3: NonTerminal.AnonList1_2,
      ) extends AnonList1_2

      case object _2 extends AnonList1_2

    }

    sealed trait ArgList extends NonTerminal
    object ArgList {

      final case class _1(
        _1: Token.__.`(`,
        _2: NonTerminal.AnonList1,
        _3: Token.__.`)`,
        _4: NonTerminal.`Optional_!`,
      ) extends ArgList

    }

    sealed trait `Optional_!` extends NonTerminal {

      def toOption: Option[Token.__.`!`] =
        this match {
          case `Optional_!`._1(n) =>
            n.some
          case `Optional_!`._2 =>
            None
        }

    }
    object `Optional_!` {

      final case class _1(
        _1: Token.__.`!`,
      ) extends `Optional_!`

      case object _2 extends `Optional_!`

    }

  }

}

object Parser extends arch.Parser[String, List[String], Data.NonTerminal.ArgList] {
  import Data._

  private val lexer: Dfa[Token] = ???
  private val grammar: Builder[Token, NonTerminal, NonTerminal.ArgList]#StateMachine = ???

  override def apply(input: String): List[String] \/ NonTerminal.ArgList =
    arch.Parser(lexer, grammar)(input)

}
