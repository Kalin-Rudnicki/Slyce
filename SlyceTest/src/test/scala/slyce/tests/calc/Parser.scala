// DO NOT EDIT : Automatically generated by Slyce v0.1.0 @ 11/22/2020
package slyce.tests.calc

import scala.annotation.tailrec

import scalaz.\/
import scalaz.-\/
import scalaz.\/-
import scalaz.Scalaz.ToBooleanOpsFromBoolean
import scalaz.Scalaz.ToOptionIdOps

import slyce.common.helpers._
import slyce.parse._
import slyce.parse.{architecture => arch}

object Data {

  sealed trait Token extends Dfa.Token
  sealed trait HasSpanToken extends Token with Dfa.Token.HasSpan
  object Token {
    case object EOF extends Token
    object __ {

      def apply(str: String, span: Dfa.Token.Span): Token =
        str match {
          case "\n" =>
            `\n`.apply(span)
          case "=" =>
            `=`.apply(span)
          case "(" =>
            `(`.apply(span)
          case ")" =>
            `)`.apply(span)
          case _ =>
            ???
        }

      final case class `\n`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `=`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `(`(span: Dfa.Token.Span) extends HasSpanToken
      final case class `)`(span: Dfa.Token.Span) extends HasSpanToken
    }
    final case class _var(text: String, span: Dfa.Token.Span) extends HasSpanToken
    final case class addOp(text: String, span: Dfa.Token.Span) extends HasSpanToken with NonTerminal.Expr.Operator
    final case class comment(text: String, span: Dfa.Token.Span) extends HasSpanToken
    final case class float(text: String, span: Dfa.Token.Span) extends HasSpanToken
    final case class int(text: String, span: Dfa.Token.Span) extends HasSpanToken
    final case class multOp(text: String, span: Dfa.Token.Span) extends HasSpanToken with NonTerminal.Expr.Operator
    final case class powOp(text: String, span: Dfa.Token.Span) extends HasSpanToken with NonTerminal.Expr.Operator
  }
  object HasSpanToken {
    def unapply(arg: HasSpanToken): Option[Dfa.Token.Span] = arg.span.some
  }

  sealed trait NonTerminal
  object NonTerminal {

    sealed trait __Start extends NonTerminal
    object __Start {

      final case class _1(
          _1: NonTerminal.Lines,
          _2: Token.EOF.type,
      ) extends __Start

    }

    sealed trait AnonList1 extends NonTerminal {

      def toList: List[Token.__.`\n`] = {
        @tailrec
        def loop(unseen: AnonList1, seen: List[Token.__.`\n`]): List[Token.__.`\n`] =
          unseen match {
            case AnonList1._1(n, tail) =>
              loop(tail, n :: seen)
            case AnonList1._2 =>
              seen.reverse
          }

        loop(this, Nil)
      }

    }
    object AnonList1 {

      final case class _1(
          _1: Token.__.`\n`,
          _2: NonTerminal.AnonList1,
      ) extends AnonList1

      case object _2 extends AnonList1

    }

    sealed trait AnonList2 extends NonTerminal {

      def toList: List[Token.__.`\n`] = {
        @tailrec
        def loop(unseen: AnonList2_2, seen: List[Token.__.`\n`]): List[Token.__.`\n`] =
          unseen match {
            case AnonList2_2._1(n, tail) =>
              loop(tail, n :: seen)
            case AnonList2_2._2 =>
              seen.reverse
          }

        this match {
          case AnonList2._1(n, tail) =>
            loop(tail, n :: Nil)
        }
      }

    }
    object AnonList2 {

      final case class _1(
          _1: Token.__.`\n`,
          _2: NonTerminal.AnonList2_2,
      ) extends AnonList2

    }

    sealed trait AnonList2_2 extends NonTerminal
    object AnonList2_2 {

      final case class _1(
          _1: Token.__.`\n`,
          _2: NonTerminal.AnonList2_2,
      ) extends AnonList2_2

      case object _2 extends AnonList2_2

    }

    sealed trait AnonList3 extends NonTerminal {

      def toList: List[NonTerminal.Line] = {
        @tailrec
        def loop(unseen: AnonList3_2, seen: List[NonTerminal.Line]): List[NonTerminal.Line] =
          unseen match {
            case AnonList3_2._1(_, n, tail) =>
              loop(tail, n :: seen)
            case AnonList3_2._2 =>
              seen.reverse
          }

        this match {
          case AnonList3._1(n, tail) =>
            loop(tail, n :: Nil)
          case AnonList3._2 =>
            Nil
        }
      }

    }
    object AnonList3 {

      final case class _1(
          _1: NonTerminal.Line,
          _2: NonTerminal.AnonList3_2,
      ) extends AnonList3

      case object _2 extends AnonList3

    }

    sealed trait AnonList3_2 extends NonTerminal
    object AnonList3_2 {

      final case class _1(
          _1: NonTerminal.AnonList2,
          _2: NonTerminal.Line,
          _3: NonTerminal.AnonList3_2,
      ) extends AnonList3_2

      case object _2 extends AnonList3_2

    }

    sealed trait Assign extends NonTerminal
    object Assign {

      final case class _1(
          _1: Token._var,
          _2: Token.__.`=`,
          _3: NonTerminal.Expr,
      ) extends Assign

    }

    sealed trait Expr extends NonTerminal {

      def toExpr: Expression[Expr.Operand, Expr.Operator] =
        this match {
          case Expr._1(left, op, right) =>
            Expression(left.toExpr, op, right.toExpr)
          case Expr._2(child) =>
            child.toExpr
        }

    }
    object Expr {

      sealed trait Operator
      type Operand = Expr_4

      final case class _1(
          _1: NonTerminal.Expr,
          _2: Token.addOp,
          _3: NonTerminal.Expr_2,
      ) extends Expr

      final case class _2(
          _1: NonTerminal.Expr_2,
      ) extends Expr

    }

    sealed trait Expr_2 extends NonTerminal {

      def toExpr: Expression[Expr.Operand, Expr.Operator] =
        this match {
          case Expr_2._1(left, op, right) =>
            Expression(left.toExpr, op, right.toExpr)
          case Expr_2._2(child) =>
            child.toExpr
        }

    }
    object Expr_2 {

      final case class _1(
          _1: NonTerminal.Expr_2,
          _2: Token.multOp,
          _3: NonTerminal.Expr_3,
      ) extends Expr_2

      final case class _2(
          _1: NonTerminal.Expr_3,
      ) extends Expr_2

    }

    sealed trait Expr_3 extends NonTerminal {

      def toExpr: Expression[Expr.Operand, Expr.Operator] =
        this match {
          case Expr_3._1(left, op, right) =>
            Expression(left.toExpr, op, right.toExpr)
          case Expr_3._2(child) =>
            child.toExpr
        }

    }
    object Expr_3 {

      final case class _1(
          _1: NonTerminal.Expr_4,
          _2: Token.powOp,
          _3: NonTerminal.Expr_3,
      ) extends Expr_3

      final case class _2(
          _1: NonTerminal.Expr_4,
      ) extends Expr_3

    }

    sealed trait Expr_4 extends NonTerminal {

      def toExpr: Expression[Expr.Operand, Expr.Operator] =
        Expression(this)

    }
    object Expr_4 {

      final case class _1(
          _1: Token.__.`(`,
          _2: NonTerminal.Expr,
          _3: Token.__.`)`,
      ) extends Expr_4

      final case class _2(
          _1: Token.int,
      ) extends Expr_4

      final case class _3(
          _1: Token.float,
      ) extends Expr_4

      final case class _4(
          _1: Token._var,
      ) extends Expr_4

    }

    sealed trait Line extends NonTerminal
    object Line {

      final case class _1(
          _1: NonTerminal.Expr,
      ) extends Line

      final case class _2(
          _1: NonTerminal.Assign,
      ) extends Line

      final case class _3(
          _1: Token.comment,
      ) extends Line

    }

    sealed trait Lines extends NonTerminal
    object Lines {

      final case class _1(
          _1: NonTerminal.AnonList1,
          _2: NonTerminal.AnonList3,
          _3: NonTerminal.AnonList1,
      ) extends Lines

    }

  }

}

object Parser extends arch.Parser[String, List[String], Data.NonTerminal.Lines] {
  import Data._

  private val lexer: Dfa[Token] = ???
  private val grammar: Builder[Token, NonTerminal, NonTerminal.Lines]#StateMachine = ???

  override def apply(input: String): List[String] \/ NonTerminal.Lines =
    arch.Parser(lexer, grammar)(input)

}
