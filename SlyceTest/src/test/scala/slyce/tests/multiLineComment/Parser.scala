// DO NOT EDIT : Automatically generated by Slyce v0.1.0 @ 11/22/2020
package slyce.tests.multiLineComment

import scala.annotation.tailrec

import scalaz.\/
import scalaz.-\/
import scalaz.\/-
import scalaz.Scalaz.ToBooleanOpsFromBoolean
import scalaz.Scalaz.ToOptionIdOps

import slyce.common.helpers._
import slyce.parse._
import slyce.parse.{architecture => arch}

object Data {

  sealed trait Token extends Dfa.Token
  sealed trait HasSpanToken extends Token with Dfa.Token.HasSpan
  object Token {
    case object EOF extends Token
    final case class comment(text: String, span: Dfa.Token.Span) extends HasSpanToken
    final case class multiLineComment(text: String, span: Dfa.Token.Span) extends HasSpanToken
  }
  object HasSpanToken {
    def unapply(arg: HasSpanToken): Option[Dfa.Token.Span] = arg.span.some
  }

  sealed trait NonTerminal
  object NonTerminal {

    sealed trait __Start extends NonTerminal
    object __Start {

      final case class _1(
        _1: NonTerminal.Comments,
        _2: Token.EOF.type,
      ) extends __Start

    }

    sealed trait Comment extends NonTerminal
    object Comment {

      final case class _1(
        _1: Token.comment,
      ) extends Comment

      final case class _2(
        _1: Token.multiLineComment,
      ) extends Comment

    }

    sealed trait Comments extends NonTerminal {

      def toList: List[NonTerminal.Comment] = {
        @tailrec
        def loop(unseen: Comments, seen: List[NonTerminal.Comment]): List[NonTerminal.Comment] =
          unseen match {
            case Comments._1(n, tail) =>
              loop(tail, n :: seen)
            case Comments._2 =>
              seen.reverse
          }

          loop(this, Nil)
      }

    }
    object Comments {

      final case class _1(
        _1: NonTerminal.Comment,
        _2: NonTerminal.Comments,
      ) extends Comments

      case object _2 extends Comments

    }

  }

}

object Parser extends arch.Parser[String, List[String], Data.NonTerminal.Comments] {
  import Data._

  private val lexer: Dfa[Token] = {
    lazy val s0: Dfa.State[Token] =
      Dfa.State(
        id = 0,
        transitions = Map(
          0x9.toChar -> Some(Lazy(s1)), // '\t'
          0xA.toChar -> Some(Lazy(s1)), // '\n'
          0x20.toChar -> Some(Lazy(s1)), // ' '
          0x2F.toChar -> Some(Lazy(s6)), // '/'
        ),
        elseTransition = None,
        yields = None,
      )
    lazy val s1: Dfa.State[Token] =
      Dfa.State(
        id = 1,
        transitions = Map.empty,
        elseTransition = None,
        yields = Some(Dfa.State.Yields(s0)()),
      )
    lazy val s2: Dfa.State[Token] =
      Dfa.State(
        id = 2,
        transitions = Map(
          0x2A.toChar -> Some(Lazy(s5)), // '*'
        ),
        elseTransition = None,
        yields = None,
      )
    lazy val s3: Dfa.State[Token] =
      Dfa.State(
        id = 3,
        transitions = Map.empty,
        elseTransition = None,
        yields = Some(
          Dfa.State.Yields(s0)(
            Dfa.State.Yields.Yield(
              tokF = Token.multiLineComment.apply,
              spanRange = (0,-1),
            ),
          ),
        ),
      )
    lazy val s4: Dfa.State[Token] =
      Dfa.State(
        id = 4,
        transitions = Map(
          0xA.toChar -> None, // '\n'
        ),
        elseTransition = Some(Lazy(s4)),
        yields = Some(
          Dfa.State.Yields(s0)(
            Dfa.State.Yields.Yield(
              tokF = Token.comment.apply,
              spanRange = (0,-1),
            ),
          ),
        ),
      )
    lazy val s5: Dfa.State[Token] =
      Dfa.State(
        id = 5,
        transitions = Map(
          0x2F.toChar -> Some(Lazy(s3)), // '/'
        ),
        elseTransition = None,
        yields = None,
      )
    lazy val s6: Dfa.State[Token] =
      Dfa.State(
        id = 6,
        transitions = Map(
          0x2A.toChar -> Some(Lazy(s2)), // '*'
          0x2F.toChar -> Some(Lazy(s4)), // '/'
        ),
        elseTransition = None,
        yields = None,
      )

    Dfa(s0, Token.EOF)
  }

  private val grammar: Builder[Token, NonTerminal, NonTerminal.Comments]#StateMachine =
    Builder.builder[Token, NonTerminal, NonTerminal.Comments].build { builder =>
      val elem: Matcher[builder.StackFrame.StackElement, builder.ElementT] = { element =>
        builder.StackFrame.StackElement.unapply(element).map(_._3)
      }
      val stateElem: Matcher[builder.StackFrame.StackElement, (builder.State, builder.ElementT)] = { element =>
        builder.StackFrame.StackElement.unapply(element).map { case (_1, _, _3) => (_1, _3) }
      }

      lazy val s0: builder.State =
        builder.State(
          id = 0,
          acceptF = Some {
            case -\/(_: Token.comment) => s1
            case \/-(_: NonTerminal.Comment) => s2
            case \/-(_: NonTerminal.Comments) => s5
            case -\/(_: Token.multiLineComment) => s3
          },
          returnFs = Nil,
          spontaneouslyGenerates = List(
            NonTerminal.Comments._2,
          ),
          finalReturnF = None,
        )
      lazy val s1: builder.State =
        builder.State(
          id = 1,
          acceptF = None,
          returnFs = List(
            {
              case stateElem(state, -\/(_1: Token.comment)) :: stackT =>
                (
                  state,
                  NonTerminal.Comment._1(_1),
                  stackT,
                )
            },
          ),
          spontaneouslyGenerates = Nil,
          finalReturnF = None,
        )
      lazy val s2: builder.State =
        builder.State(
          id = 2,
          acceptF = Some {
            case -\/(_: Token.comment) => s1
            case \/-(_: NonTerminal.Comment) => s2
            case \/-(_: NonTerminal.Comments) => s4
            case -\/(_: Token.multiLineComment) => s3
          },
          returnFs = Nil,
          spontaneouslyGenerates = List(
            NonTerminal.Comments._2,
          ),
          finalReturnF = None,
        )
      lazy val s3: builder.State =
        builder.State(
          id = 3,
          acceptF = None,
          returnFs = List(
            {
              case stateElem(state, -\/(_1: Token.multiLineComment)) :: stackT =>
                (
                  state,
                  NonTerminal.Comment._2(_1),
                  stackT,
                )
            },
          ),
          spontaneouslyGenerates = Nil,
          finalReturnF = None,
        )
      lazy val s4: builder.State =
        builder.State(
          id = 4,
          acceptF = None,
          returnFs = List(
            {
              case elem(\/-(_2: NonTerminal.Comments)) :: stateElem(state, \/-(_1: NonTerminal.Comment)) :: stackT =>
                (
                  state,
                  NonTerminal.Comments._1(_1, _2),
                  stackT,
                )
            },
          ),
          spontaneouslyGenerates = Nil,
          finalReturnF = None,
        )
      lazy val s5: builder.State =
        builder.State(
          id = 5,
          acceptF = Some {
            case -\/(Token.EOF) => s6
          },
          returnFs = Nil,
          spontaneouslyGenerates = Nil,
          finalReturnF = None,
        )
      lazy val s6: builder.State =
        builder.State(
          id = 6,
          acceptF = None,
          returnFs = Nil,
          spontaneouslyGenerates = Nil,
          finalReturnF = Some {
            case elem(-\/(Token.EOF)) :: elem(\/-(rawTree: NonTerminal.Comments)) :: Nil =>
              rawTree
          },
        )

      s0
    } {
      case (t1 @ HasSpanToken(s1), t2 @ HasSpanToken(s2)) =>
        (s2.start.abs > s1.start.abs).fold(t2, t1)
      case (eof @ Token.EOF, _) =>
        eof
      case (_, eof) =>
        eof
    }

  override def apply(input: String): List[String] \/ NonTerminal.Comments =
    arch.Parser(lexer, grammar)(input)

}
